####################
# Normal distr     #
####################

normal_mle <- function(data) {
  # Ensure data is valid
  if (length(data) == 0) stop("Data cannot be empty")
  
  # Define the negative log-likelihood function
  neg_log_likelihood <- function(params, data) {
    mu <- params[1]
    sigma <- params[2]
    
    if (sigma <= 0) return(Inf)  # Standard deviation must be positive
    
    # Negative log-likelihood of Normal distribution
    return(-sum(dnorm(data, mean = mu, sd = sigma, log = TRUE)))
  }
  
  # Initial guesses: sample mean and standard deviation
  init_params <- c(mean(data), sd(data))
  
  # Use optim() to find the MLE of mu and sigma
  mle_result <- optim(
    par = init_params,
    fn = neg_log_likelihood,
    data = data,
    method = "L-BFGS-B",
    lower = c(-Inf, 1e-6)  # Only restrict sigma > 0
  )
  
  # Return MLE estimates of mu and sigma
  return(list(mu = mle_result$par[1], sigma = mle_result$par[2]))
}

# Example usage
set.seed(123)
data <- rnorm(100, mean = 5, sd = 2)  # Generate 100 Normal observations
mle_estimates <- normal_mle(data)
cat("MLE estimate of mu:", mle_estimates$mu, "\n")
cat("MLE estimate of sigma:", mle_estimates$sigma, "\n")


##########################
# Comparing two datasets #
##########################

# Simulate data with different means but same variance
set.seed(42)
data1 <- rnorm(100, mean = 0, sd = 2)
data2 <- rnorm(100, mean = 1, sd = 2)

# Combine data and group labels
data <- c(data1, data2)
group <- factor(rep(1:2, each = 100))

# --- Null Model: shared mean and shared sigma ---
neg_log_lik_null <- function(params, data, group) {
  mu <- params[1]
  sigma <- params[2]
  if (sigma <= 0) return(Inf)
  -sum(dnorm(data, mean = mu, sd = sigma, log = TRUE))
}

init_null <- c(mean(data), sd(data))
fit_null <- optim(
  par = init_null,
  fn = neg_log_lik_null,
  data = data,
  group = group,
  method = "L-BFGS-B",
  lower = c(-Inf, 1e-6)
)
logL_null <- -fit_null$value

# --- Alternative Model: different means, shared sigma ---
neg_log_lik_alt <- function(params, data, group) {
  mu1 <- params[1]
  mu2 <- params[2]
  sigma <- params[3]
  if (sigma <= 0) return(Inf)
  ll <- ifelse(group == 1,
               dnorm(data, mean = mu1, sd = sigma, log = TRUE),
               dnorm(data, mean = mu2, sd = sigma, log = TRUE))
  -sum(ll)
}

init_alt <- c(mean(data1), mean(data2), sqrt((var(data1) + var(data2))/2))
fit_alt <- optim(
  par = init_alt,
  fn = neg_log_lik_alt,
  data = data,
  group = group,
  method = "L-BFGS-B",
  lower = c(-Inf, -Inf, 1e-6)
)
logL_alt <- -fit_alt$value

# --- LRT ---
lrt_stat <- 2 * (logL_alt - logL_null)
p_value <- pchisq(lrt_stat, df = 1, lower.tail = FALSE)

# Output
cat("Log-likelihood (Null):", logL_null, "\n")
cat("Log-likelihood (Alt):", logL_alt, "\n")
cat("LRT Statistic:", lrt_stat, "\n")
cat("p-value:", p_value, "\n")


t.test(data1, data2, var.equal = T)


# Difference in means and CI
mu1_hat <- fit_alt$par[1]
mu2_hat <- fit_alt$par[2]
sigma_hat <- fit_alt$par[3]
mean_diff_hat <- mu1_hat - mu2_hat

n1 <- sum(group == 1)
n2 <- sum(group == 2)
se_diff <- sigma_hat * sqrt(1/n1 + 1/n2)
z <- qnorm(0.975)
ci_lower <- mean_diff_hat - z * se_diff
ci_upper <- mean_diff_hat + z * se_diff

# Output
cat("Mean Difference (mu1 - mu2):", mean_diff_hat, "\n")
cat("95% CI for Difference:", ci_lower, "to", ci_upper, "\n")

